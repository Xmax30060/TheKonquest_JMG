<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <title>Carte Monde Territoires Optimisée Paramétrable</title>
    <style>
        body {
            margin: 0; overflow: hidden;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            background: #eef4fb;
            user-select:none;
        }
        #toolbar {
            position: absolute;
            top: 10px; left: 10px;
            background: white;
            padding: 10px 14px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.12);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            max-width: 400px;
            z-index: 1000;
        }
        label {
            font-size: 0.9rem;
            margin-right: 4px;
            white-space: nowrap;
        }
        input[type=number] {
            width: 70px;
            padding: 4px 6px;
            font-size: 1rem;
            border: 1px solid #ccc;
            border-radius: 6px;
        }
        button {
            font-size: 1rem;
            padding: 6px 14px;
            border: none;
            border-radius: 6px;
            background: #1d71b8;
            color: white;
            cursor: pointer;
            transition: background 0.25s ease;
            flex-grow: 1;
            max-width: 150px;
        }
        button:hover {
            background: #155a85;
        }
        svg {
            width: 100vw;
            height: 100vh;
            cursor: grab;
            background: #a5c9ff;
        }
        svg:active {
            cursor: grabbing;
        }
        .territory {
            stroke: #222;
            stroke-width: 0.6;
            fill-opacity: 0.75;
            cursor: pointer;
            transition: fill-opacity 0.3s ease, stroke-width 0.3s ease;
        }
        .territory:hover {
            fill-opacity: 1;
            stroke-width: 1.3;
        }
        text {
            font-size: 10px;
            pointer-events: none;
            user-select:none;
            fill: #222;
            text-shadow: 0 0 3px white;
        }
        #tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(0,0,0,0.75);
            color: white;
            padding: 5px 10px;
            font-size: 13px;
            border-radius: 5px;
            white-space: nowrap;
            display: none;
            user-select:none;
            z-index: 10000;
        }
    </style>
</head>
<body>
<div id="toolbar">
    <a href="index.html"><button>Retour</button></a>
    <span id="loading" style="display:none; margin-left:10px; font-style:italic;">Chargement...</span>
</div>
<svg></svg>
<div id="tooltip"></div>
<script type="module" src="js/firestore.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson@3"></script>
<script>
    const svg = d3.select("svg");
    const width = window.innerWidth;
    const height = window.innerHeight;

    const projection = d3.geoEquirectangular()
        .scale(width / (2 * Math.PI))
        .translate([width/2, height/2]);

    const path = d3.geoPath(projection);

    const tooltip = d3.select("#tooltip");
    let territoriesGroup, labelsGroup;

    const zoom = d3.zoom()
        .scaleExtent([1, 8])
        .on("zoom", (event) => {
            territoriesGroup.attr("transform", event.transform);
            labelsGroup.attr("transform", event.transform);
            labelsGroup.attr("font-size", 10 / event.transform.k);
        });
    svg.call(zoom);

    // Ramer-Douglas-Peucker simplification polygon
    function simplifyRDP(points, epsilon) {
        if(points.length < 3) return points;

        const sqrDist = (p1, p2) => {
            const dx = p1[0] - p2[0];
            const dy = p1[1] - p2[1];
            return dx*dx + dy*dy;
        };

        function perpendicularDistance(pt, lineStart, lineEnd) {
            const x = pt[0], y = pt[1];
            const x1 = lineStart[0], y1 = lineStart[1];
            const x2 = lineEnd[0], y2 = lineEnd[1];

            const dx = x2 - x1;
            const dy = y2 - y1;

            if(dx === 0 && dy === 0) {
                return Math.sqrt(sqrDist(pt, lineStart));
            }

            const t = ((x - x1)*dx + (y - y1)*dy) / (dx*dx + dy*dy);
            let proj;
            if(t < 0) proj = lineStart;
            else if(t > 1) proj = lineEnd;
            else proj = [x1 + t*dx, y1 + t*dy];

            return Math.sqrt(sqrDist(pt, proj));
        }

        function rdp(points, epsilon) {
            let maxDist = 0;
            let index = -1;
            for(let i=1; i < points.length-1; i++) {
                const dist = perpendicularDistance(points[i], points[0], points[points.length-1]);
                if(dist > maxDist) {
                    index = i;
                    maxDist = dist;
                }
            }

            if(maxDist > epsilon) {
                const left = rdp(points.slice(0, index+1), epsilon);
                const right = rdp(points.slice(index), epsilon);

                return left.slice(0, -1).concat(right);
            } else {
                return [points[0], points[points.length-1]];
            }
        }

        return rdp(points, epsilon);
    }

    // Simplifie GeoJSON Polygon ou MultiPolygon selon tolérance epsilon
    function simplifyFeature(feature, epsilon=0.5) {
        const geom = feature.geometry;

        if(geom.type === "Polygon") {
            const simplifiedCoords = geom.coordinates.map(ring => simplifyRDP(ring, epsilon));
            return {
                ...feature,
                geometry: {type: "Polygon", coordinates: simplifiedCoords}
            };
        } else if(geom.type === "MultiPolygon") {
            const simplifiedCoords = geom.coordinates.map(polygon =>
                polygon.map(ring => simplifyRDP(ring, epsilon))
            );
            return {
                ...feature,
                geometry: {type: "MultiPolygon", coordinates: simplifiedCoords}
            };
        }
        return feature;
    }

    // Arrondir coordonnées GeoJSON à une précision donnée
    function roundCoordinates(feature, precision=2) {
        function roundCoord(coord) {
            return coord.map(ring =>
                ring.map(point =>
                    point.map(c => +c.toFixed(precision))
                )
            );
        }
        const geom = feature.geometry;

        if(geom.type === "Polygon") {
            return {
                ...feature,
                geometry: {type: "Polygon", coordinates: roundCoord(geom.coordinates)}
            };
        } else if(geom.type === "MultiPolygon") {
            return {
                ...feature,
                geometry: {
                    type: "MultiPolygon",
                    coordinates: geom.coordinates.map(roundCoord)
                }
            };
        }
        return feature;
    }

    // Distance euclidienne simple lon/lat
    function lonLatDistance(a, b) {
        const dx = a[0]-b[0];
        const dy = a[1]-b[1];
        return Math.sqrt(dx*dx + dy*dy);
    }

    // Regroupe features en n territoires avec k-means et seuil distance minimum entre centroïdes
    function regroupTerritories(features, n, epsilon, minDist, precision) {
        // Simplification + arrondi
        const simpleFeatures = features.map(f => roundCoordinates(simplifyFeature(f, epsilon), precision));

        // Calcul centroïdes
        const centroids = simpleFeatures.map(f => ({feature: f, centroid: d3.geoCentroid(f)}));

        // Init clusters en évitant centroïdes trop proches
        let clusters = [];
        let usedIndices = new Set();

        function isFarEnough(cand) {
            return clusters.every(c => lonLatDistance(c.centroid, cand) > minDist);
        }

        for(let i=0; i<centroids.length && clusters.length < n; i++) {
            const c = centroids[i];
            if(isFarEnough(c.centroid)) {
                clusters.push({
                    id: clusters.length,
                    centroid: c.centroid.slice(),
                    features: []
                });
                usedIndices.add(i);
            }
        }

        while(clusters.length < n) {
            const idx = Math.floor(Math.random() * centroids.length);
            if(!usedIndices.has(idx)) {
                clusters.push({
                    id: clusters.length,
                    centroid: centroids[idx].centroid.slice(),
                    features: []
                });
                usedIndices.add(idx);
            }
        }

        // K-means
        function dist(a,b) {
            const dx = a[0]-b[0];
            const dy = a[1]-b[1];
            return dx*dx + dy*dy;
        }

        let moved = true;
        let iter = 0;
        const maxIter = 20;

        while(moved && iter < maxIter) {
            iter++;
            clusters.forEach(c => c.features = []);
            centroids.forEach(cen => {
                let bestCluster = clusters[0];
                let bestDist = dist(cen.centroid, bestCluster.centroid);
                for(let i=1; i<clusters.length; i++) {
                    const cd = dist(cen.centroid, clusters[i].centroid);
                    if(cd < bestDist) {
                        bestCluster = clusters[i];
                        bestDist = cd;
                    }
                }
                bestCluster.features.push(cen.feature);
            });
            moved = false;
            clusters.forEach(c => {
                if(c.features.length === 0) return;
                let x = 0, y = 0;
                c.features.forEach(f => {
                    const ctd = d3.geoCentroid(f);
                    x += ctd[0];
                    y += ctd[1];
                });
                x /= c.features.length;
                y /= c.features.length;

                if(dist(c.centroid,[x,y]) > 1e-8){
                    c.centroid = [x,y];
                    moved = true;
                }
            });
        }

        // Fusionne features des clusters en MultiPolygon
        return clusters.map(c => {
            const combined = {
                type: "Feature",
                geometry: {
                    type: "MultiPolygon",
                    coordinates: []
                },
                properties: {
                    name: `Territoire ${c.id+1}`
                }
            };
            c.features.forEach(f => {
                if(f.geometry.type === "Polygon") {
                    combined.geometry.coordinates.push(f.geometry.coordinates);
                } else if(f.geometry.type === "MultiPolygon") {
                    combined.geometry.coordinates.push(...f.geometry.coordinates);
                }
            });
            return combined;
        });
    }

    // Affiche la carte
    function renderMap(territories) {
        svg.selectAll("*").remove();
        territoriesGroup = svg.append("g");
        labelsGroup = svg.append("g");

        territoriesGroup.selectAll("path")
            .data(territories)
            .join("path")
            .attr("class", "territory")
            .attr("d", path)
            .attr("fill", (_,i) => d3.interpolateTurbo(i / territories.length))
            .on("mousemove", (event,d) => {
                tooltip.style("display", "block")
                    .style("left", (event.pageX + 15) + "px")
                    .style("top", (event.pageY + 15) + "px")
                    .text(d.properties.name);
            })
            .on("mouseout", () => {
                tooltip.style("display", "none");
            });

        labelsGroup.selectAll("text")
            .data(territories)
            .join("text")
            .attr("x", d => {
                const c = d3.geoCentroid(d);
                return isNaN(c[0]) ? 0 : projection(c)[0];
            })
            .attr("y", d => {
                const c = d3.geoCentroid(d);
                return isNaN(c[1]) ? 0 : projection(c)[1];
            })
            .text(d => d.properties.name)
            .attr("font-size", 10)
            .attr("text-anchor", "middle")
            .style("pointer-events", "none")
            .style("user-select", "none");
    }

    async function loadAndRender(n, epsilon, minDist, precision) {
        d3.select("#loading").style("display", "inline");
        try {
            const world = await d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json");
            const countries = topojson.feature(world, world.objects.countries).features;

            const territories = regroupTerritories(countries, n, epsilon, minDist, precision);
            renderMap(territories);
        } catch(e) {
            alert("Erreur de chargement des données : " + e);
            console.error(e);
        }
        d3.select("#loading").style("display", "none");
    }
    // Initial load with defaults
    loadAndRender(
        +170,
        +0,
        +0,
        +100
    );

</script>
</body>
</html>
